module Control.FSM.Monad.Internal (MachineT(..), runMachineT, FSM(..), EffectfulFSM(..), FSMValidTransition(..), FSMTransition(..)) where

import Control.Monad.Except
import Control.Monad.Reader.Class
import Control.Monad.Writer.Class
import Control.Monad.State
import Data.Kind
import GHC.TypeLits

-- | This monad transformer wraps the effect monad @m@ that the FSM @mach@ uses. For 'mtl' style code, you'll have to derive any other instances you need.
newtype MachineT mach m a = MachineT { unMachineT :: StateT (StateType mach) m a }
                          deriving (Functor, Applicative, Monad, MonadTrans)

-- | This converts the 'MachineT' representation of a state machine's actions into a monadic action in the effect monad.
runMachineT :: (FSM mach) => MachineT mach (EffectMonad mach) a -> EffectMonad mach (a, StateType mach)
runMachineT m = runStateT (unMachineT m) initialState

instance (MonadError e m) => MonadError e (MachineT mach m) where
    throwError = lift . throwError
    catchError (MachineT m) handler = MachineT $ catchError m (unMachineT . handler)

instance (MonadReader r m) => MonadReader r (MachineT mach m) where
    ask = lift ask
    reader = lift . reader
    local f (MachineT m) = MachineT $ local f m

instance (MonadWriter w m) => MonadWriter w (MachineT mach m) where
    writer = lift . writer
    tell = lift . tell
    listen (MachineT m) = MachineT $ listen m
    pass (MachineT m) = MachineT $ pass m

instance (MonadState s m) => MonadState s (MachineT mach m) where
    state f = MachineT $ lift (state f)

-- | An instance of this class represents a particular FSM generated by this library.
class (EffectfulFSM mach) => FSM mach where
    -- | This holds @mach@'s event data type, obfuscating the event type.
    data EventType mach :: Type
    -- | This is the base event data type.
    type EventType' mach = (out :: k -> Type) | out -> mach
    -- | This holds @mach@'s state data type, obfuscating the event type.
    data StateType mach :: Type
    -- | This is the base state data type.
    type StateType' mach = (out :: k -> Type) | out -> mach

    initialState :: StateType mach
    pump :: EventType mach -> MachineT mach (EffectMonad mach) ()

class EffectfulFSM mach where
    type EffectMonad mach :: Type -> Type

class FSMValidTransition (mach :: machine) (from :: state) (via :: event) (to :: state)

class (FSM mach, FSMValidTransition mach from via to) => FSMTransition mach from via to where
    doTransition :: StateType' mach from -> EventType' mach via -> EffectMonad mach (StateType' mach to)
